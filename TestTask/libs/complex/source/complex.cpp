#include "complex/complex.h"
#include <iostream>
#include <math.h>

/*
template <typename T>
double Complex<T>::abs()
{
    return sqrt(Re * Re + Im * Im);
}

template <typename T>
std::ostream& operator<<(std::ostream & os, Complex<T>  const& c)
{
    os << c.Re << ((c.Im >= 0) ? (" + ") : (" - ")) << ((c.Im >= 0) ? (c.Im) : (-c.Im)) << "i" << std::endl;
    return os;
}

template <typename T>
Complex<T> conj(Complex<T> & c1)
{
   Complex<T> res;
   res.Re = c1.Re;
   res.Im = -c1.Im;
   return res;
}

template <typename T>
Complex<T> operator+(const Complex<T>& c1, const Complex<T>& c2){
            Complex<T> res;
            res.Re = c1.Re + c2.Re;
            res.Im = c1.Im + c2.Im;
            return res;
}

template <typename T>
Complex<T> operator-(const Complex<T>& c1, const Complex<T>& c2){
            Complex<T> res;
            res.Re = c1.Re - c2.Re;
            res.Im = c1.Im - c2.Im;
            return res;
}

template <typename T>
Complex<T> operator*(const Complex<T>& c1, const Complex<T>& c2){
            Complex<T> res;
            res.Re = (c1.Re * c2.Re) - (c1.Im * c2.Im);
            res.Im = (c1.Re * c2.Im) + (c1.Im * c2.Re);
            return res;
}

template <typename T>
Complex<T> operator/(const Complex<T>& c1, const Complex<T>& c2){
            Complex<T> res;
            res.Re = ((c1.Re * c2.Re) + (c1.Im * c2.Im)) / (c2.Re * c2.Re + c2.Im * c2.Im);
            res.Im = ((c1.Im * c2.Re) - (c1.Re * c2.Im)) / (c2.Re * c2.Re + c2.Im * c2.Im);
            return res;
}*/

/*
Complex add(Complex & c1, Complex & c2)
{
   Complex res;
   res.Re = c1.Re + c2.Re;
   res.Im = c1.Im + c2.Im;
   return res;
}

Complex dif(Complex & c1, Complex & c2)
{
   Complex res;
   res.Re = c1.Re - c2.Re;
   res.Im = c1.Im - c2.Im;
   return res;
}
*/
